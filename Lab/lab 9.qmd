---
title: "lab 9"
format: html
---

```{r}
library(tidyverse)
```

## **Exercise 1. DNA or RNA? (45 minutes)**

#### **1.1 Write a function, `dna_or_rna(sequence)`, that determines if a sequence of base pairs is DNA, RNA, or if it is not possible to tell given the sequence provided.**

-   Since all the function will know about the material is the sequence, the only way to tell the difference between DNA and RNA is that RNA has the base Uracil (`"u"`) instead of the base Thymine (`"t"`).

-   Have the function return one of three outputs: “DNA”, “RNA”, or “unknown”. Then run the following three lines of code:

`dna_or_rna("attggc")`

`dna_or_rna("gccaau")`

`dna_or_rna("ccagac")`

`dna_or_rna("tgcacug")`

Hint: the `str_split` function might be helpful.

```{r}
dna_or_rna <- function(sequence){
  bases <- strsplit(sequence, "") |>
    unlist() |>
    unique()
     
    if (all(bases %in% c("a", "t", "g", "c")) && "t" %in% bases){
      return("DNA")
    } else if (all(bases %in% c("a", "u", "g", "c")) && "u" %in% bases){
      return("RNA")
    } else {
      return("unknown")
    }
}
```

```{r}
dna_or_rna("attggc")
dna_or_rna("gccaau")
dna_or_rna("ccagac")
dna_or_rna("tgcacug")
```

#### **1.2 Use the `dna_or_rna()` function and a for loop to print the type of the sequences in the following list.**

```{r}
sequences = c(
  "ttgaatgccttacaactgatcattacacaggcggcatgaagcaaaaatatactgtgaaccaatgcaggcg", 
  "gauuauuccccacaaagggagugggauuaggagcugcaucauuuacaagagcagaauguuucaaaugcau", 
  "gaaagcaagaaaaggcaggcgaggaagggaagaagggggggaaacc", 
  "guuuccuacaguauuugaugagaaugagaguuuacuccuggaagauaauauuagaauguuuacaacugcaccugaucagguggauaaggaagaugaagacu", 
  "gataaggaagaugaagacutucaggaaucuaauaaaaugcacuccaugaauggauucauguaugggaaucagccggguc"
)
```

```{r}
sequence_type <- vector("double", length(sequences))
for (i in seq_along(sequences)){
  sequence_type[i] <- dna_or_rna(sequences[i])
}

sequence_type
```

#### **1.3 Use the `dna_or_rna()` function and an appropriate map function to print the type of the sequences in the above list.**

```{r}
map_chr(sequences, dna_or_rna)
```

#### **1.4 Make your function work with both upper and lower case letters, or even strings with mixed capitalization. Test your function with the following three lines of code:**

`dna_or_rna("ATTGGC")`

`dna_or_rna("gCCAAu")`

`dna_or_rna("ggcacgG")`

```{r}
dna_or_rna <- function(sequence){
  bases <- str_split(sequence, pattern ="") |>
    unlist() |>
    tolower() |>
    unique()
  
  if(all(bases %in% c("a", "t", "g", "c")) & "t" %in% bases){
    return("DNA")
  } else if (all(bases %in% c("a", "u", "g", "c")) & "u" %in% bases){
    return("RNA")
  } else {
    return("unknown")
  }
}
```

```{r}
dna_or_rna("ATTGGC")
dna_or_rna("gCCAAu")
dna_or_rna("ggcacgG")
```

## **Exercise 2: Rounding (50 minutes)**

#### **2.1 To correct this inconsistency issue, write a custom function that consistently applies a [round half away from zero rule](https://en.wikipedia.org/wiki/Rounding#Round_half_away_from_zero).**

-   Under this rule, when rounding off a **5** , your function should round up when it’s positive, and down when it is negative

-   Your function should takes a “digits” argument exactly as in the original R function.

**Hint:** you may need the arithmetic operator `%/%` and the `sign()` function.

```{r}

round_away <- function(x, digits=0){
  x_new <- abs(x*10^digits)
  x_sign <- sign(x)
  
  integer <- x_new%/%1
  decimal <- x_new-integer
  
  if(decimal<0.5){
    x_new <- integer
  } else{
    x_new <- integer +1
  } 
  
  x_rounded <- x_new/10^digits*x_sign
  return(x_rounded)
}
```

```{r}
round_away(0.55, digits=0)
round_away(2.45, digits=0)
round_away(-0.55, digits=0)
round_away(-2.45, digits=0)

round_away(0.55, digits=1)
round_away(2.45, digits=1)
round_away(-0.55, digits=1)
round_away(-2.45, digits=1)
```

#### **2.2 Now, building on the previous question, write a custom function that consistently applies a round half to even rule when rounding off a 5.**

**Hint:** you will need the arithmetic operator `%%`.

```{r}
round_even <- function(x, digits=0){
  x_new <- abs(x*10^digits)
  x_sign <- sign(x)
  
  integer <- x_new%/%1
  decimal <- x_new-integer
  
  if(decimal<0.5){
    x_new <-integer
  } else if (decimal == 0.5){
    if(integer%%2==0){
      x_new <- integer
    } else {
      x_new <- integer +1
    } 
  } else {
    x_new <- integer +1
  }
  
  x_rounded <- x_new/10^digits*x_sign
  return(x_rounded)
}
```

```{r}
round_even(0.55, digits=0)
round_even(2.45, digits=0)
round_even(-0.55, digits=0)
round_even(-2.45, digits=0)

round_even(0.55, digits=1)
round_even(2.45, digits=1)
round_even(-0.55, digits=1)
round_even(-2.45, digits=1)
```
